<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment images ###rgregedferfdd伟大的无多无群多的 我的钱无 插入图片测试 二次测试 xx size往欧尼轻 往欧尼轻 不在沉默中爆发，就在沉默中灭亡。color=#00ffff**color=#00ffff color=#00ffff 我看都买了** kernel 内核管理相关，进程调度等 sched/fork等fs 文件子系统 ext4/f2fs/fuse/debugfs/proc等 header 1 header 2 jj kernel 内核管理相关，进程调度等 sched/fork等 fs 文件子系统 ext4/f2fs/fuse/debugfs/proc等 莺歌1中0 ==球哥4中1== 哈特4中0球师弟3中1 最近几天在看关于Android系统开机启动过程的相关内容。做个笔记dddddss。 Idina Menze和Caleb Hyles激情对唱Let It Go： wwerdw3 video plugin edwq r6tu6 ddd dd (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"https://www.youtube.com/embed/KEv85JKnA2w","pic":"http://b.hiphotos.baidu.com/image/h%3D300/sign=08b730528f025aafcc3278cbcbecab8d/f3d3572c11dfa9ec53b720856fd0f703908fc183.jpg"},"danmaku":{"id":"9E2E3368B56CDBB4","api":"http://dplayer.daoapp.io","token":"tokendemo"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Telephony</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android7.0 拨号盘应用源码分析]]></title>
    <url>%2F2018%2F12%2F15%2FAndroid7.0%20%E6%8B%A8%E5%8F%B7%E7%9B%98%E5%BA%94%E7%94%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言android拨号盘的源码目录在package/app/Dialer 自7.0以后Incallui的源码直接放到了Dialer目录下，虽然在7.0以前incallui有自己独立的目录，但实际编译过程中只是作为链接库最后还是被编译到Dialer的apk里 博主这里只取Dialer相关的源码并导入AS中，并稍作调整兼容至L 源码目录结构如下： 先理一理各个工程的依赖关系 com.android.dialer是主工程依赖于 com.android.contacts.common工程和com.android.phone.common工程 com.android.contacts.common又依赖于 com.android.phone.common工程和com.android.common工程 1.1拨号盘概览先来看看几张原图 1.2 DialtactsActivity 主activity为DialtactsActivity 12345678910111213141516171819202122com.android.dialer.DialtactsActivitypublic class DialtactsActivity extends TransactionSafeActivity 。。。&#123; // Fragment containing the dialpad that slides into view protected DialpadFragment mDialpadFragment; // Fragment for searching phone numbers using the alphanumeric keyboard. private RegularSearchFragment mRegularSearchFragment; // Fragment for searching phone numbers using the dialpad. private SmartDialSearchFragment mSmartDialSearchFragment; // Fragment containing the speed dial list, call history list, and all contacts list. private ListsFragment mListsFragment; private DialerDatabaseHelper mDialerDatabaseHelper; private FloatingActionButtonController mFloatingActionButtonController; ...... ...... ...... ..... &#125; 1234567891011om.android.dialer.dialpad .DialpadFragment // 拨号盘fragmentcom.android.dialer.list.RegularSearchFragment // 联系人搜索fragmentcom.android.dialer.list.SmartDialSearchFragment // 拨号搜索fragmentcom.android.dialer.list.ListsFragment // TAB页fragment，包含快速联系人，最近通话记录，联系人列表三个子fragmentcom.android.dialer.database.DialerDatabaseHelper // 拨号搜索数据库SQLiteOpenHelper对象com.android.contacts.common.widget.FloatingActionButtonController // 悬浮按钮控制器 再看看onCreate里的主要实现（部分内容省略） 123456789101112131415161718192021222324252627282930313233@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.dialtacts_activity); final ActionBar actionBar = getSupportActionBar(); actionBar.setCustomView(R.layout.search_edittext); // 给actionbar设置自定义view （SearchEditTextLayout） SearchEditTextLayout searchEditTextLayout = (SearchEditTextLayout) actionBar .getCustomView().findViewById(R.id.search_view_container); // 给SearchEditTextLayout添加管理器ActionBarController mActionBarController = new ActionBarController(this, searchEditTextLayout); final View floatingActionButtonContainer = findViewById( R.id.floating_action_button_container); ImageButton floatingActionButton = (ImageButton) findViewById(R.id.floating_action_button); floatingActionButton.setOnClickListener(this); // 用FloatingActionButtonController管理悬浮按钮 mFloatingActionButtonController = new FloatingActionButtonController(this, floatingActionButtonContainer, floatingActionButton); // 添加ListsFragment getFragmentManager().beginTransaction() .add(R.id.dialtacts_frame, new ListsFragment(), TAG_FAVORITES_FRAGMENT) .commit(); // 初始化单例对象DialerDatabaseHelper mDialerDatabaseHelper = DatabaseHelperManager.getDatabaseHelper(this); SmartDialPrefix.initializeNanpSettings(this);&#125; 1.3 ListsFragmentListsFragment是主fragment，结构如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ListsFragment extends Fragment&#123; private ViewPager mViewPager; private ViewPagerTabs mViewPagerTabs; // 自定义TAB标签，继承自HorizontalScrollView private ViewPagerAdapter mViewPagerAdapter; // 拖拽常用联系人时悬浮视图 private RemoveView mRemoveView; private View mRemoveViewContent; // 常用联系人fragment private SpeedDialFragment mSpeedDialFragment; // 最近通话记录fragment private CallLogFragment mHistoryFragment; // 联系人列表fragment private AllContactsFragment mAllContactsFragment; // Voicemail列表fragment private CallLogFragment mVoicemailFragment; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; final View parentView = inflater.inflate(R.layout.lists_fragment, container, false); mViewPager = (ViewPager) parentView.findViewById(R.id.lists_pager); mViewPagerAdapter = new ViewPagerAdapter(getChildFragmentManager()); mViewPager.setAdapter(mViewPagerAdapter); mViewPager.setOffscreenPageLimit(TAB_COUNT_WITH_VOICEMAIL - 1); mViewPager.setOnPageChangeListener(this); showTab(TAB_INDEX_SPEED_DIAL); ...... ...... ...... ...... mViewPagerTabs = (ViewPagerTabs) parentView.findViewById(R.id.lists_pager_header); mViewPagerTabs.configureTabIcons(mTabIcons); mViewPagerTabs.setViewPager(mViewPager); addOnPageChangeListener(mViewPagerTabs); mRemoveView = (RemoveView) parentView.findViewById(R.id.remove_view); mRemoveViewContent = parentView.findViewById(R.id.remove_view_content); return parentView; &#125;&#125; ListsFragment最多可以显示四个fragment，有个VisualVoicemailCallLogFragment显示一种特定的通话记录（提供视频语音邮件服务） 类型为Calls.VOICEMAIL_TYPE，需要运营商支持，只有存在该类通话记录才会显示该TAB页，国内运营商暂不支持 ‘ SpeedDialFragment显示常用联系人列表 1234567891011121314151617181920212223242526272829public class SpeedDialFragment extends Fragment ...&#123; // 显示数据的GridView列表 private PhoneFavoriteListView mListView; // 源数据BaseAdapter private PhoneFavoritesTileAdapter mContactTileAdapter; // 查询源数据的LoaderCallbacks private class ContactTileLoaderListener implements LoaderManager.LoaderCallbacks&lt;Cursor&gt; &#123; @Override public CursorLoader onCreateLoader(int id, Bundle args) &#123; if (DEBUG) Log.d(TAG, "ContactTileLoaderListener#onCreateLoader."); return ContactTileLoaderFactory.createStrequentPhoneOnlyLoader(getActivity()); &#125; @Override public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) &#123; if (DEBUG) Log.d(TAG, "ContactTileLoaderListener#onLoadFinished"); mContactTileAdapter.setContactCursor(data); setEmptyViewVisibility(mContactTileAdapter.getCount() == 0); &#125; @Override public void onLoaderReset(Loader&lt;Cursor&gt; loader) &#123; if (DEBUG) Log.d(TAG, "ContactTileLoaderListener#onLoaderReset. "); &#125; &#125;&#125; 使用LoadManager方式获取cursor数据，查询ContactsProvider数据库的data表 1234567com.android.contacts.common.ContactTileLoaderFactorypublic static CursorLoader createStrequentPhoneOnlyLoader(Context context) &#123; Uri uri = Contacts.CONTENT_STREQUENT_URI.buildUpon() .appendQueryParameter(ContactsContract.STREQUENT_PHONE_ONLY, "true").build(); return new CursorLoader(context, uri, COLUMNS_PHONE_ONLY, null, null, null);&#125; 数据来源包括收藏的联系人以及有通话记录的联系人 1.4 DialpadFragmentDialpadFragment显示拨号盘fragment 在DialtactsActivity中添加如下 123456789private void showDialpadFragment(boolean animate) &#123; if (mDialpadFragment == null) &#123; mDialpadFragment = new DialpadFragment(); ft.add(R.id.dialtacts_container, mDialpadFragment, TAG_DIALPAD_FRAGMENT); &#125; else &#123; ft.show(mDialpadFragment); &#125; &#125; 第一次显示时动态添加进去，后续动态控制显示隐藏 123456789101112131415161718192021222324252627282930313233343536public class DialpadFragment extends Fragment&#123; private DialpadView mDialpadView; // 拨号数字面板（包括输入号码框） private EditText mDigits; // 输入号码框 private ToneGenerator mToneGenerator; // DTMF音播放器 private ListView mDialpadChooser; // 通话状态时显示的视图 private DialpadChooserAdapter mDialpadChooserAdapter; // 通话状态时显示的视图adapter @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedState) &#123; // 横竖屏加载不同的布局 final View fragmentView = inflater.inflate(R.layout.dialpad_fragment, container, false); fragmentView.buildLayer(); mDialpadView = (DialpadView) fragmentView.findViewById(R.id.dialpad_view); mDialpadView.setCanDigitsBeEdited(true); mDigits = mDialpadView.getDigits(); ...... ........... ...... PhoneNumberFormatter.setPhoneNumberFormattingTextWatcher(getActivity(), mDigits); // 格式化输入框中的号码 // Check for the presence of the keypad View oneButton = fragmentView.findViewById(R.id.one); if (oneButton != null) &#123; // 绑定各个数字按键onPress事件 configureKeypadListeners(fragmentView); &#125; ...... ............ ...... mDialpadChooser = (ListView) fragmentView.findViewById(R.id.dialpadChooser); mDialpadChooser.setOnItemClickListener(this); ...... ..... ...... ...... return fragmentView; &#125;&#125; 横屏和竖屏所加载的拨号面板布局是不一样的 DialpadView是个自定义视图，主要用于显示数字按键和输入号码框 123456789101112131415161718192021222324252627282930313233public class DialpadView extends LinearLayout &#123; private EditText mDigits; // 输入号码框 private ImageButton mDelete; // 删除按钮 private void setupKeypad() &#123; ...... ............ ...... DialpadKeyButton dialpadKey; TextView numberView; TextView lettersView; ...... ............ ...... for (int i = 0; i &lt; mButtonIds.length; i++) &#123; dialpadKey = (DialpadKeyButton) findViewById(mButtonIds[i]); numberView = (TextView) dialpadKey.findViewById(R.id.dialpad_key_number); lettersView = (TextView) dialpadKey.findViewById(R.id.dialpad_key_letters); ...... ............ ...... final RippleDrawable rippleBackground = (RippleDrawable) getDrawableCompat(getContext(), R.drawable.btn_dialpad_key); if (mRippleColor != null) &#123; rippleBackground.setColor(mRippleColor); &#125; numberView.setText(numberString); numberView.setElegantTextHeight(false); dialpadKey.setContentDescription(numberContentDescription); dialpadKey.setBackground(rippleBackground); // 设置数字按键水波纹背景色 if (lettersView != null) &#123; lettersView.setText(resources.getString(letterIds[i])); &#125; &#125; ...... ............ ...... &#125; 1234567891011121314151617181920212223public void animateShow() &#123; // 显示拨号面板时各个数字按键的动画效果 ...... ............ ...... for (int i = 0; i &lt; mButtonIds.length; i++) &#123; ...... ............ ...... ViewPropertyAnimator animator = dialpadKey.animate(); if (mIsLandscape) &#123; // Landscape orientation requires translation along the X axis. // For RTL locales, ensure we translate negative on the X axis. dialpadKey.setTranslationX((mIsRtl ? -1 : 1) * mTranslateDistance); animator.translationX(0); &#125; else &#123; // Portrait orientation requires translation along the Y axis. dialpadKey.setTranslationY(mTranslateDistance); animator.translationY(0); &#125; animator.setInterpolator(AnimUtils.EASE_OUT_EASE_IN) .setStartDelay(delay) .setDuration(duration) .setListener(showListener) .start(); &#125; &#125;&#125; 当处于通话状态时显示如下 1.5SmartDialSearchFragment RegularSearchFragmentSmartDialSearchFragment显示拨号搜索结果fragment（在拨号面板输入数字时显示） RegularSearchFragment显示联系人搜索结果fragment（在actionbar输入框输入字符时显示） 在DialtactsActivity中进入或退出搜索模式时动态添加移除 123456789101112131415161718192021222324252627282930private void enterSearchUi(boolean smartDialSearch, String query, boolean animate) &#123; ...... ............ ...... if (fragment == null) &#123; if (smartDialSearch) &#123; fragment = new SmartDialSearchFragment(); &#125; else &#123; fragment = ObjectFactory.newRegularSearchFragment(); ...... ............ ...... &#125; transaction.add(R.id.dialtacts_frame, fragment, tag); &#125; else &#123; transaction.show(fragment); &#125; ...... ............ ...... &#125; private void exitSearchUi() &#123; ...... ............ ...... final FragmentTransaction transaction = getFragmentManager().beginTransaction(); if (mSmartDialSearchFragment != null) &#123; transaction.remove(mSmartDialSearchFragment); &#125; if (mRegularSearchFragment != null) &#123; transaction.remove(mRegularSearchFragment); &#125; transaction.commit(); mListsFragment.getView().animate().alpha(1).withLayer(); ...... ............ ...... mActionBarController.onSearchUiExited(); &#125; 拨号搜素只能通过拨号面板的输入数字，支持T9搜索，但是原生不支持拼音检索 12345678910111213141516171819202122232425262728public class SmartDialSearchFragment extends SearchFragment&#123; @Override protected ContactEntryListAdapter createListAdapter() &#123; SmartDialNumberListAdapter adapter = new SmartDialNumberListAdapter(getActivity()); adapter.setUseCallableUri(super.usesCallableUri()); adapter.setQuickContactEnabled(true); // Set adapter's query string to restore previous instance state. adapter.setQueryString(getQueryString()); adapter.setListener(this); return adapter; &#125; @Override public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) &#123; // Smart dialing does not support Directory Load, falls back to normal search instead. if (id == getDirectoryLoaderId()) &#123; return super.onCreateLoader(id, args); &#125; else &#123; final SmartDialNumberListAdapter adapter = (SmartDialNumberListAdapter) getAdapter(); SmartDialCursorLoader loader = new SmartDialCursorLoader(super.getContext()); adapter.configureLoader(loader); return loader; &#125; &#125;&#125; 联系人搜索则通过软键盘输入，不过不支持T9搜索 1234567891011public class RegularSearchFragment extends SearchFragment&#123; @Override protected ContactEntryListAdapter createListAdapter() &#123; RegularSearchListAdapter adapter = new RegularSearchListAdapter(getActivity()); adapter.setDisplayPhotos(true); adapter.setUseCallableUri(usesCallableUri()); adapter.setListener(this); return adapter; &#125;&#125; 从类关系图上可以得知两个fragment和对应的adapter都继承于同一个父类，最终都派生自ContactsCommon工程里的模板类ContactEntryListFragment 1234567891011121314151617181920212223242526272829303132public abstract class ContactEntryListFragment&lt;T extends ContactEntryListAdapter&gt; extends Fragment&#123; private T mAdapter; // 模板adapter private View mView; private ListView mListView; private ContactPhotoManager mPhotoManager; // 头像管理 protected abstract View inflateView(LayoutInflater inflater, ViewGroup container); protected abstract T createListAdapter(); // 子类中实现具体adapter @Override // 子类可重写获取数据的Loader public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) &#123; if (id == DIRECTORY_LOADER_ID) &#123; DirectoryListLoader loader = new DirectoryListLoader(mContext); loader.setDirectorySearchMode(mAdapter.getDirectorySearchMode()); loader.setLocalInvisibleDirectoryEnabled( ContactEntryListAdapter.LOCAL_INVISIBLE_DIRECTORY_ENABLED); return loader; &#125; else &#123; CursorLoader loader = createCursorLoader(mContext); long directoryId = args != null &amp;&amp; args.containsKey(DIRECTORY_ID_ARG_KEY) ? args.getLong(DIRECTORY_ID_ARG_KEY) : Directory.DEFAULT; mAdapter.configureLoader(loader, directoryId); return loader; &#125; &#125;&#125; ContactEntryListFragment内部封装了很多操作，绑定了ContactEntryListAdapter，具体细节就不在这里详述了 1.6小结最后附上Dialer里主要类图]]></content>
      <categories>
        <category>Telephony</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 系统服务TelecomService启动过程分析]]></title>
    <url>%2F2018%2F01%2F04%2FAndroid%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1TelecomService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[由于一直负责的是Android Telephony部分的开发工作，对于通信过程的上层部分Telecom服务以及UI都没有认真研究过。最近恰好碰到一个通话方面的问题，涉及到了Telecom部分，因而就花时间仔细研究了下相关的代码。这里做一个简单的总结。这篇文章，主要以下两个部分的内容： 什么是Telecom服务?其作用是什么？ Telecom模块的启动与初始化过程； 接下来一篇文章，主要以实际通话过程为例，分析下telephony收到来电后如何将电话信息发送到Telecom模块以及Telecom是如何处理来电。 什么是Telecom服务Telecom是Android的一个系统服务，其主要作用是管理Android系统当前的通话,如来电显示，接听电话，挂断电话等功能，在Telephony模块与上层UI之间起到了一个桥梁的作用。比如，Telephony有接收到新的来电时，首先会告知Telecom,然后由Telecom服务通知上层应用来电信息，并显示来电界面。 Telecom服务对外提供了一个接口类TelecomManager,通过其提供的接口，客户端可以查询通话状态，发送通话请求以及添加通话链接等。 从Telecom进程对应的AndroidManifest.xml文件来看，Telecom进程的用户ID跟系统进程用户ID相同，是系统的核心服务。那么，其中android:process=”system”这个属性值表示什么意思了？查看官方文档，这个表示Telecom将启动在进程system中，这样可以跟其他进程进行资源共享了（对于Android这个全局进程，就是SystemServer所在的进程）。 android:processBy setting this attribute to a process name that’s shared with another application, you can arrange for components of both applications to run in the same process — but only if the two applications also share a user ID and be signed with the same certificate.If the name assigned to this attribute begins with a colon (‘:’), a new process, private to the application, is created when it’s needed. If the process name begins with a lowercase character, a global process of that name is created. A global process can be shared with other applications, reducing resource usage. 1234567891011121314151617181920212223242526272829&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:androidprv=&quot;http://schemas.android.com/apk/prv/res/android&quot; package=&quot;com.android.server.telecom&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0.0&quot; coreApp=&quot;true&quot; android:sharedUserId=&quot;android.uid.system&quot;&gt; &lt;application android:label=&quot;@string/telecommAppLabel&quot; android:icon=&quot;@mipmap/ic_launcher_phone&quot; android:allowBackup=&quot;false&quot; android:supportsRtl=&quot;true&quot; android:process=&quot;system&quot; android:usesCleartextTraffic=&quot;false&quot; android:defaultToDeviceProtectedStorage=&quot;true&quot; android:directBootAware=&quot;true&quot;&gt; .... // 包含TelecomService &lt;service android:name=&quot;.components.TelecomService&quot; android:singleUser=&quot;true&quot; android:process=&quot;system&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.telecom.ITelecomService&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; .... &lt;/application&gt;&lt;/manifest&gt; 代码路径: /android/applications/sources/services/Telecomm/ /android/frameworks/base/telecomm/ 了解了什么是Telecom服务之后，就来看一看Telecom服务是如何启动与初始化的。 Telecom进程的启动与初始化在SystemServer进程初始化完成启动完系统的核心服务如==ActivityManagerService==后，就会加载系统其它服务,这其中就包含了一个与Telecom服务启动相关的系统服务专门用于加载Telecom： 12345678private void startOtherServices() &#123; .... //启动TelecomLoaderService系统服务，用于加载Telecom mSystemServiceManager.startService(TelecomLoaderService.class); // 启动telephony注册服务，用于注册监听telephony状态的接口 telephonyRegistry = new TelephonyRegistry(context); ServiceManager.addService(&quot;telephony.registry&quot;, telephonyRegistry); &#125; 调用系统服务管家SystemServiceManager的接口startService创建新的服务，并注册到系统中，最后调用onStart()启动服务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class SystemServiceManager &#123; @SuppressWarnings(&quot;unchecked&quot;) public SystemService startService(String className) &#123; final Class&lt;SystemService&gt; serviceClass; try &#123; serviceClass = (Class&lt;SystemService&gt;)Class.forName(className); &#125; catch (ClassNotFoundException ex) &#123; .... &#125; return startService(serviceClass); &#125; // 服务的class文件来创建新的服务对象(服务必须继承SystemService) @SuppressWarnings(&quot;unchecked&quot;) public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123; try &#123; final String name = serviceClass.getName(); Slog.i(TAG, &quot;Starting &quot; + name); Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, &quot;StartService &quot; + name); // Create the service. if (!SystemService.class.isAssignableFrom(serviceClass)) &#123; throw new RuntimeException(&quot;Failed to create &quot; + name + &quot;: service must extend &quot; + SystemService.class.getName()); &#125; final T service; try &#123; Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); &#125; catch (InstantiationException ex) &#123; throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service could not be instantiated&quot;, ex); &#125; .... // Register it. mServices.add(service); // Start it. try &#123; service.onStart(); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(&quot;Failed to start service &quot; + name + &quot;: onStart threw an exception&quot;, ex); &#125; return service; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125; &#125; &#125; 创建TelecomLoaderService系统服务，将系统默认的SMS应用，拨号应用以及SIM通话管理应用（不知道这个什么鬼）告知PackageManagerService(PMS)，以便在适当的时候可以找到应用。 首先，注册默认应用(SMS/Dialer etc)通知对象，以便这些应用发送变更（如下载了一个第三方的SMS应用时，可以通知系统这一变化）； 接着，注册运营商配置变化的广播接收器，如果配置有变化时，系统会收到通知； 绑定TelecomService，并将其注册到系统中。 12345678910111213141516171819202122232425262728293031323334353637383940public class TelecomLoaderService extends SystemService &#123; private static final ComponentName SERVICE_COMPONENT = new ComponentName( &quot;com.android.server.telecom&quot;, &quot;com.android.server.telecom.components.TelecomService&quot;); private static final String SERVICE_ACTION = &quot;com.android.ITelecomService&quot;; // 当前系统启动的阶段 @Override public void onBootPhase(int phase) &#123; if (phase == PHASE_ACTIVITY_MANAGER_READY) &#123; registerDefaultAppNotifier(); registerCarrierConfigChangedReceiver(); connectToTelecom(); &#125; &#125; //绑定Telecom服务 private void connectToTelecom() &#123; synchronized (mLock) &#123; if (mServiceConnection != null) &#123; // TODO: Is unbinding worth doing or wait for system to rebind? mContext.unbindService(mServiceConnection); mServiceConnection = null; &#125; TelecomServiceConnection serviceConnection = new TelecomServiceConnection(); Intent intent = new Intent(SERVICE_ACTION); intent.setComponent(SERVICE_COMPONENT); int flags = Context.BIND_IMPORTANT | Context.BIND_FOREGROUND_SERVICE | Context.BIND_AUTO_CREATE; // Bind to Telecom and register the service if (mContext.bindServiceAsUser(intent, serviceConnection, flags, UserHandle.SYSTEM)) &#123; mServiceConnection = serviceConnection; &#125; &#125; &#125; &#125; 服务绑定：https://developer.android.com/guide/components/bound-services.html 1234567891011121314151617181920212223242526public class TelecomLoaderService extends SystemService &#123; private class TelecomServiceConnection implements ServiceConnection &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // Normally, we would listen for death here, but since telecom runs in the same process // as this loader (process=&quot;system&quot;) thats redundant here. try &#123; service.linkToDeath(new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; connectToTelecom(); &#125; &#125;, 0); SmsApplication.getDefaultMmsApplication(mContext, false); //添加Telecom服务 ServiceManager.addService(Context.TELECOM_SERVICE, service); .... &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; connectToTelecom(); &#125; &#125; &#125; 绑定服务时，调用TelecomService的onBind接口，对整个Telecom系统进行初始化，并返回一个IBinder接口: 12345678910111213141516/** * Implementation of the ITelecom interface. */ public class TelecomService extends Service implements TelecomSystem.Component &#123; @Override public IBinder onBind(Intent intent) &#123; // 初始化整个Telecom系统 initializeTelecomSystem(this); //返回IBinder接口 synchronized (getTelecomSystem().getLock()) &#123; return getTelecomSystem().getTelecomServiceImpl().getBinder(); &#125; &#125; &#125; Telecom系统初始化，主要工作是新建一个TelecomSystem的类，在这个类中，会对整个Telecom服务的相关类都初始化： 12345678910111213static void initializeTelecomSystem(Context context) &#123; if (TelecomSystem.getInstance() == null) &#123; final NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE); // 用于获取联系人 contactInfoHelper = new ContactInfoHelper(context); // 新建一个单例模式的对象 TelecomSystem.setInstance(new TelecomSystem(....)); &#125; .... &#125; &#125; 构造一个单例TelecomSystem对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public TelecomSystem( Context context, /* 用户未接来电通知类（不包括已接或者拒绝的电话） */ MissedCallNotifierImplFactory missedCallNotifierImplFactory, /* 查询来电信息 */ CallerInfoAsyncQueryFactory callerInfoAsyncQueryFactory, /* 耳机接入状态监听 */ HeadsetMediaButtonFactory headsetMediaButtonFactory, /* 距离传感器管理 */ ProximitySensorManagerFactory proximitySensorManagerFactory, /* 通话时电话管理 */ InCallWakeLockControllerFactory inCallWakeLockControllerFactory, /* 音频服务管理 */ AudioServiceFactory audioServiceFactory, /* 蓝牙设备管理 */ BluetoothPhoneServiceImplFactory bluetoothPhoneServiceImplFactory, BluetoothVoIPServiceImplFactory bluetoothVoIPServiceImplFactory, /* 查询所有超时信息 */ Timeouts.Adapter timeoutsAdapter, /* 响铃播放 */ AsyncRingtonePlayer asyncRingtonePlayer, /* 电话号码帮助类 */ PhoneNumberUtilsAdapter phoneNumberUtilsAdapter, /* 通话时阻断通知 */ InterruptionFilterProxy interruptionFilterProxy) &#123; mContext = context.getApplicationContext(); // 初始化telecom相关的feature TelecomFeature.makeFeature(mContext); // 初始化telecom的数据库 TelecomSystemDB.initialize(mContext); // 创建一个PhoneAccount注册管理类 mPhoneAccountRegistrar = new PhoneAccountRegistrar(mContext); .... // 初始化通话管家，正是它负责与上层UI的交互 mCallsManager = new CallsManager( mContext, mLock, mContactsAsyncHelper, callerInfoAsyncQueryFactory, mMissedCallNotifier, mPhoneAccountRegistrar, headsetMediaButtonFactory, proximitySensorManagerFactory, inCallWakeLockControllerFactory, audioServiceFactory, bluetoothManager, wiredHeadsetManager, systemStateProvider, defaultDialerAdapter, timeoutsAdapter,AsyncRingtonePlayer, phoneNumberUtilsAdapter, interruptionFilterProxy); CallsManager.initialize(mCallsManager); // 注册需要接收的广播 mContext.registerReceiver(mUserSwitchedReceiver, USER_SWITCHED_FILTER); mContext.registerReceiver(mUserStartingReceiver, USER_STARTING_FILTER); mContext.registerReceiver(mFeatureChangedReceiver, FEATURE_CHANGED_FILTER); mContext.registerReceiver(mEmergencyReceiver, EMERGENCY_STATE_CHANGED); .... // 所有来电与去电的处理中转站 mCallIntentProcessor = new CallIntentProcessor(mContext, mCallsManager); // 创建一个TelecomServiceImpl用于调用TelecomService的接口 mTelecomServiceImpl = new TelecomServiceImpl( mContext, mCallsManager, mPhoneAccountRegistrar, new CallIntentProcessor.AdapterImpl(), new UserCallIntentProcessorFactory() &#123; @Override public UserCallIntentProcessor create(Context context, UserHandle userHandle) &#123; return new UserCallIntentProcessor(context, userHandle); &#125; &#125;, defaultDialerAdapter, new TelecomServiceImpl.SubscriptionManagerAdapterImpl(), mLock); // 执行特定的初始化操作 initialize(mContext); &#125; &#125; Android Telephony中的PhoneAccount到底起到个什么作用了？按照源码中的说明来理解，PhoneAccount表示了不同的接听或者拨打电话的方式，比如用户可以通过SIM卡来拨打电话，也可以拨打视频电话，抑或一个紧急通话，甚至可以通过telephony内部的接口来实现拨号，而Android正是通过PhoneAccount来区分这几种通话方式的。与之相对应的一个类PhoneAccountHandle则是用于表示哪一个用户正在使用通话服务。 至此整个Telecom服务就启动完成了，这样Telecom服务就可以处理来电或者去电了。在接下来的一篇文章里，将分析下来电是如何在Telecom中传递与处理，然后发送到上层UI界面的。]]></content>
      <categories>
        <category>Telephony</category>
      </categories>
  </entry>
</search>
