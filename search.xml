<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mat data operation in jni and java]]></title>
    <url>%2F2019%2F03%2F09%2FMat%20data%20operation%20in%20jni%20and%20java%2F</url>
    <content type="text"><![CDATA[Returning Mat object from native code to java in OpenCVin C++:12345jlong funC()&#123;Mat *mat = new Mat(); //... return (jlong)mat;&#125; in java:12long = addr;// addr is return from c method funC()Mat mat = new Mat(addr); OpenCV Mat数据类型指针ptr的使用常用形式: 1mat.ptr&lt;type&gt;(row)[col] 对于Mat的ptr函数，返回的是&lt;&gt;中的模板类型指针，指向的是()中的第row行的起点,通常&lt;&gt;中的类型和Mat的元素类型应该一致然后再用该指针去访问对应col列位置的元素 单通道1234cv::Mat image = cv::Mat(400, 600, CV_8UC1); //定义了一个Mat变量image。uchar * data00 = image.ptr&lt;uchar&gt;(0); //data00是指向image第一行第一个元素的指针。uchar * data10 = image.ptr&lt;uchar&gt;(1); //data10是指向image第二行第一个元素的指针。uchar * data01 = image.ptr&lt;uchar&gt;(0)[1];//data01是指向image第一行第二个元素的指针。 多通道12345cv::Mat image = cv::Mat(400, 600, CV_8UC3); //宽400，长600，３通道彩色图片cv::Vec3b * data000 = image.ptr&lt;cv::Vec3b&gt;(0);cv::Vec3b * data100 = image.ptr&lt;cv::Vec3b&gt;(1);cv::Vec3b * data001 = image.ptr&lt;cv::Vec3b&gt;(0)[1];cv::Vec3b * data jni层简单打印12345678910for (int i=0;i&lt;grey.rows;i++) &#123; for (int j=0;j&lt;grey.cols*grey.channels();j++) &#123; //double ImgPixelVal = cvGetReal2D( grey, i, j ); LOGD("print src img:%d",grey.ptr&lt;int&gt;(i)[j]); // cout&lt;&lt;src.ptr(j)&lt;&lt;endl; &#125; &#125;]]></content>
      <categories>
        <category>openCV</category>
      </categories>
      <tags>
        <tag>openCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo function test]]></title>
    <url>%2F2019%2F03%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 插入图片测试 插入图片测试二次测试 字体测试不在沉默中爆发，就在沉默中灭亡。 表格测试 header 1 header 2 jj kernel 内核管理相关，进程调度等 sched/fork等 fs 文件子系统 ext4/f2fs/fuse/debugfs/proc等 插入视频测试 插入视频测试(方式2)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 系统服务TelecomService启动过程分析]]></title>
    <url>%2F2018%2F01%2F04%2FAndroid%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1TelecomService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[由于一直负责的是Android Telephony部分的开发工作，对于通信过程的上层部分Telecom服务以及UI都没有认真研究过。最近恰好碰到一个通话方面的问题，涉及到了Telecom部分，因而就花时间仔细研究了下相关的代码。这里做一个简单的总结。这篇文章，主要以下两个部分的内容： 什么是Telecom服务?其作用是什么？ Telecom模块的启动与初始化过程； 接下来一篇文章，主要以实际通话过程为例，分析下telephony收到来电后如何将电话信息发送到Telecom模块以及Telecom是如何处理来电。 什么是Telecom服务Telecom是Android的一个系统服务，其主要作用是管理Android系统当前的通话,如来电显示，接听电话，挂断电话等功能，在Telephony模块与上层UI之间起到了一个桥梁的作用。比如，Telephony有接收到新的来电时，首先会告知Telecom,然后由Telecom服务通知上层应用来电信息，并显示来电界面。 Telecom服务对外提供了一个接口类TelecomManager,通过其提供的接口，客户端可以查询通话状态，发送通话请求以及添加通话链接等。 从Telecom进程对应的AndroidManifest.xml文件来看，Telecom进程的用户ID跟系统进程用户ID相同，是系统的核心服务。那么，其中android:process=”system”这个属性值表示什么意思了？查看官方文档，这个表示Telecom将启动在进程system中，这样可以跟其他进程进行资源共享了（对于Android这个全局进程，就是SystemServer所在的进程）。 android:processBy setting this attribute to a process name that’s shared with another application, you can arrange for components of both applications to run in the same process — but only if the two applications also share a user ID and be signed with the same certificate.If the name assigned to this attribute begins with a colon (‘:’), a new process, private to the application, is created when it’s needed. If the process name begins with a lowercase character, a global process of that name is created. A global process can be shared with other applications, reducing resource usage. 1234567891011121314151617181920212223242526272829&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:androidprv=&quot;http://schemas.android.com/apk/prv/res/android&quot; package=&quot;com.android.server.telecom&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0.0&quot; coreApp=&quot;true&quot; android:sharedUserId=&quot;android.uid.system&quot;&gt; &lt;application android:label=&quot;@string/telecommAppLabel&quot; android:icon=&quot;@mipmap/ic_launcher_phone&quot; android:allowBackup=&quot;false&quot; android:supportsRtl=&quot;true&quot; android:process=&quot;system&quot; android:usesCleartextTraffic=&quot;false&quot; android:defaultToDeviceProtectedStorage=&quot;true&quot; android:directBootAware=&quot;true&quot;&gt; .... // 包含TelecomService &lt;service android:name=&quot;.components.TelecomService&quot; android:singleUser=&quot;true&quot; android:process=&quot;system&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.telecom.ITelecomService&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; .... &lt;/application&gt;&lt;/manifest&gt; 代码路径: /android/applications/sources/services/Telecomm/ /android/frameworks/base/telecomm/ 了解了什么是Telecom服务之后，就来看一看Telecom服务是如何启动与初始化的。 Telecom进程的启动与初始化在SystemServer进程初始化完成启动完系统的核心服务如==ActivityManagerService==后，就会加载系统其它服务,这其中就包含了一个与Telecom服务启动相关的系统服务专门用于加载Telecom： 12345678private void startOtherServices() &#123; .... //启动TelecomLoaderService系统服务，用于加载Telecom mSystemServiceManager.startService(TelecomLoaderService.class); // 启动telephony注册服务，用于注册监听telephony状态的接口 telephonyRegistry = new TelephonyRegistry(context); ServiceManager.addService(&quot;telephony.registry&quot;, telephonyRegistry); &#125; 调用系统服务管家SystemServiceManager的接口startService创建新的服务，并注册到系统中，最后调用onStart()启动服务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class SystemServiceManager &#123; @SuppressWarnings(&quot;unchecked&quot;) public SystemService startService(String className) &#123; final Class&lt;SystemService&gt; serviceClass; try &#123; serviceClass = (Class&lt;SystemService&gt;)Class.forName(className); &#125; catch (ClassNotFoundException ex) &#123; .... &#125; return startService(serviceClass); &#125; // 服务的class文件来创建新的服务对象(服务必须继承SystemService) @SuppressWarnings(&quot;unchecked&quot;) public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123; try &#123; final String name = serviceClass.getName(); Slog.i(TAG, &quot;Starting &quot; + name); Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, &quot;StartService &quot; + name); // Create the service. if (!SystemService.class.isAssignableFrom(serviceClass)) &#123; throw new RuntimeException(&quot;Failed to create &quot; + name + &quot;: service must extend &quot; + SystemService.class.getName()); &#125; final T service; try &#123; Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); &#125; catch (InstantiationException ex) &#123; throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service could not be instantiated&quot;, ex); &#125; .... // Register it. mServices.add(service); // Start it. try &#123; service.onStart(); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(&quot;Failed to start service &quot; + name + &quot;: onStart threw an exception&quot;, ex); &#125; return service; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125; &#125; &#125; 创建TelecomLoaderService系统服务，将系统默认的SMS应用，拨号应用以及SIM通话管理应用（不知道这个什么鬼）告知PackageManagerService(PMS)，以便在适当的时候可以找到应用。 首先，注册默认应用(SMS/Dialer etc)通知对象，以便这些应用发送变更（如下载了一个第三方的SMS应用时，可以通知系统这一变化）； 接着，注册运营商配置变化的广播接收器，如果配置有变化时，系统会收到通知； 绑定TelecomService，并将其注册到系统中。 12345678910111213141516171819202122232425262728293031323334353637383940public class TelecomLoaderService extends SystemService &#123; private static final ComponentName SERVICE_COMPONENT = new ComponentName( &quot;com.android.server.telecom&quot;, &quot;com.android.server.telecom.components.TelecomService&quot;); private static final String SERVICE_ACTION = &quot;com.android.ITelecomService&quot;; // 当前系统启动的阶段 @Override public void onBootPhase(int phase) &#123; if (phase == PHASE_ACTIVITY_MANAGER_READY) &#123; registerDefaultAppNotifier(); registerCarrierConfigChangedReceiver(); connectToTelecom(); &#125; &#125; //绑定Telecom服务 private void connectToTelecom() &#123; synchronized (mLock) &#123; if (mServiceConnection != null) &#123; // TODO: Is unbinding worth doing or wait for system to rebind? mContext.unbindService(mServiceConnection); mServiceConnection = null; &#125; TelecomServiceConnection serviceConnection = new TelecomServiceConnection(); Intent intent = new Intent(SERVICE_ACTION); intent.setComponent(SERVICE_COMPONENT); int flags = Context.BIND_IMPORTANT | Context.BIND_FOREGROUND_SERVICE | Context.BIND_AUTO_CREATE; // Bind to Telecom and register the service if (mContext.bindServiceAsUser(intent, serviceConnection, flags, UserHandle.SYSTEM)) &#123; mServiceConnection = serviceConnection; &#125; &#125; &#125; &#125; 服务绑定：https://developer.android.com/guide/components/bound-services.html 1234567891011121314151617181920212223242526public class TelecomLoaderService extends SystemService &#123; private class TelecomServiceConnection implements ServiceConnection &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // Normally, we would listen for death here, but since telecom runs in the same process // as this loader (process=&quot;system&quot;) thats redundant here. try &#123; service.linkToDeath(new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; connectToTelecom(); &#125; &#125;, 0); SmsApplication.getDefaultMmsApplication(mContext, false); //添加Telecom服务 ServiceManager.addService(Context.TELECOM_SERVICE, service); .... &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; connectToTelecom(); &#125; &#125; &#125; 绑定服务时，调用TelecomService的onBind接口，对整个Telecom系统进行初始化，并返回一个IBinder接口: 12345678910111213141516/** * Implementation of the ITelecom interface. */ public class TelecomService extends Service implements TelecomSystem.Component &#123; @Override public IBinder onBind(Intent intent) &#123; // 初始化整个Telecom系统 initializeTelecomSystem(this); //返回IBinder接口 synchronized (getTelecomSystem().getLock()) &#123; return getTelecomSystem().getTelecomServiceImpl().getBinder(); &#125; &#125; &#125; Telecom系统初始化，主要工作是新建一个TelecomSystem的类，在这个类中，会对整个Telecom服务的相关类都初始化： 12345678910111213static void initializeTelecomSystem(Context context) &#123; if (TelecomSystem.getInstance() == null) &#123; final NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE); // 用于获取联系人 contactInfoHelper = new ContactInfoHelper(context); // 新建一个单例模式的对象 TelecomSystem.setInstance(new TelecomSystem(....)); &#125; .... &#125; &#125; 构造一个单例TelecomSystem对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public TelecomSystem( Context context, /* 用户未接来电通知类（不包括已接或者拒绝的电话） */ MissedCallNotifierImplFactory missedCallNotifierImplFactory, /* 查询来电信息 */ CallerInfoAsyncQueryFactory callerInfoAsyncQueryFactory, /* 耳机接入状态监听 */ HeadsetMediaButtonFactory headsetMediaButtonFactory, /* 距离传感器管理 */ ProximitySensorManagerFactory proximitySensorManagerFactory, /* 通话时电话管理 */ InCallWakeLockControllerFactory inCallWakeLockControllerFactory, /* 音频服务管理 */ AudioServiceFactory audioServiceFactory, /* 蓝牙设备管理 */ BluetoothPhoneServiceImplFactory bluetoothPhoneServiceImplFactory, BluetoothVoIPServiceImplFactory bluetoothVoIPServiceImplFactory, /* 查询所有超时信息 */ Timeouts.Adapter timeoutsAdapter, /* 响铃播放 */ AsyncRingtonePlayer asyncRingtonePlayer, /* 电话号码帮助类 */ PhoneNumberUtilsAdapter phoneNumberUtilsAdapter, /* 通话时阻断通知 */ InterruptionFilterProxy interruptionFilterProxy) &#123; mContext = context.getApplicationContext(); // 初始化telecom相关的feature TelecomFeature.makeFeature(mContext); // 初始化telecom的数据库 TelecomSystemDB.initialize(mContext); // 创建一个PhoneAccount注册管理类 mPhoneAccountRegistrar = new PhoneAccountRegistrar(mContext); .... // 初始化通话管家，正是它负责与上层UI的交互 mCallsManager = new CallsManager( mContext, mLock, mContactsAsyncHelper, callerInfoAsyncQueryFactory, mMissedCallNotifier, mPhoneAccountRegistrar, headsetMediaButtonFactory, proximitySensorManagerFactory, inCallWakeLockControllerFactory, audioServiceFactory, bluetoothManager, wiredHeadsetManager, systemStateProvider, defaultDialerAdapter, timeoutsAdapter,AsyncRingtonePlayer, phoneNumberUtilsAdapter, interruptionFilterProxy); CallsManager.initialize(mCallsManager); // 注册需要接收的广播 mContext.registerReceiver(mUserSwitchedReceiver, USER_SWITCHED_FILTER); mContext.registerReceiver(mUserStartingReceiver, USER_STARTING_FILTER); mContext.registerReceiver(mFeatureChangedReceiver, FEATURE_CHANGED_FILTER); mContext.registerReceiver(mEmergencyReceiver, EMERGENCY_STATE_CHANGED); .... // 所有来电与去电的处理中转站 mCallIntentProcessor = new CallIntentProcessor(mContext, mCallsManager); // 创建一个TelecomServiceImpl用于调用TelecomService的接口 mTelecomServiceImpl = new TelecomServiceImpl( mContext, mCallsManager, mPhoneAccountRegistrar, new CallIntentProcessor.AdapterImpl(), new UserCallIntentProcessorFactory() &#123; @Override public UserCallIntentProcessor create(Context context, UserHandle userHandle) &#123; return new UserCallIntentProcessor(context, userHandle); &#125; &#125;, defaultDialerAdapter, new TelecomServiceImpl.SubscriptionManagerAdapterImpl(), mLock); // 执行特定的初始化操作 initialize(mContext); &#125; &#125; Android Telephony中的PhoneAccount到底起到个什么作用了？按照源码中的说明来理解，PhoneAccount表示了不同的接听或者拨打电话的方式，比如用户可以通过SIM卡来拨打电话，也可以拨打视频电话，抑或一个紧急通话，甚至可以通过telephony内部的接口来实现拨号，而Android正是通过PhoneAccount来区分这几种通话方式的。与之相对应的一个类PhoneAccountHandle则是用于表示哪一个用户正在使用通话服务。 至此整个Telecom服务就启动完成了，这样Telecom服务就可以处理来电或者去电了。在接下来的一篇文章里，将分析下来电是如何在Telecom中传递与处理，然后发送到上层UI界面的。]]></content>
      <categories>
        <category>Telephony</category>
      </categories>
  </entry>
</search>
